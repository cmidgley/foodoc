var _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}, Prism = function(_self) {
    var lang = /\blang(?:uage)?-([\w-]+)\b/i, uniqueId = 0, _ = {
        manual: _self.Prism && _self.Prism.manual,
        disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
        util: {
            encode: function encode(tokens) {
                return tokens instanceof Token ? new Token(tokens.type, encode(tokens.content), tokens.alias) : Array.isArray(tokens) ? tokens.map(encode) : tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            },
            type: function(o) {
                return Object.prototype.toString.call(o).slice(8, -1);
            },
            objId: function(obj) {
                return obj.__id || Object.defineProperty(obj, "__id", {
                    value: ++uniqueId
                }), obj.__id;
            },
            clone: function deepClone(o, visited) {
                var clone, id, type = _.util.type(o);
                switch (visited = visited || {}, type) {
                  case "Object":
                    if (id = _.util.objId(o), visited[id]) return visited[id];
                    for (var key in clone = {}, visited[id] = clone, o) o.hasOwnProperty(key) && (clone[key] = deepClone(o[key], visited));
                    return clone;

                  case "Array":
                    return id = _.util.objId(o), visited[id] ? visited[id] : (clone = [], visited[id] = clone, 
                    o.forEach(function(v, i) {
                        clone[i] = deepClone(v, visited);
                    }), clone);

                  default:
                    return o;
                }
            },
            getLanguage: function(element) {
                for (;element && !lang.test(element.className); ) element = element.parentElement;
                return element ? (element.className.match(lang) || [ , "none" ])[1].toLowerCase() : "none";
            },
            currentScript: function() {
                if ("undefined" == typeof document) return null;
                if ("currentScript" in document) return document.currentScript;
                try {
                    throw new Error();
                } catch (err) {
                    var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];
                    if (src) {
                        var scripts = document.getElementsByTagName("script");
                        for (var i in scripts) if (scripts[i].src == src) return scripts[i];
                    }
                    return null;
                }
            }
        },
        languages: {
            extend: function(id, redef) {
                var lang = _.util.clone(_.languages[id]);
                for (var key in redef) lang[key] = redef[key];
                return lang;
            },
            insertBefore: function(inside, before, insert, root) {
                var grammar = (root = root || _.languages)[inside], ret = {};
                for (var token in grammar) if (grammar.hasOwnProperty(token)) {
                    if (token == before) for (var newToken in insert) insert.hasOwnProperty(newToken) && (ret[newToken] = insert[newToken]);
                    insert.hasOwnProperty(token) || (ret[token] = grammar[token]);
                }
                var old = root[inside];
                return root[inside] = ret, _.languages.DFS(_.languages, function(key, value) {
                    value === old && key != inside && (this[key] = ret);
                }), ret;
            },
            DFS: function DFS(o, callback, type, visited) {
                visited = visited || {};
                var objId = _.util.objId;
                for (var i in o) if (o.hasOwnProperty(i)) {
                    callback.call(o, i, o[i], type || i);
                    var property = o[i], propertyType = _.util.type(property);
                    "Object" !== propertyType || visited[objId(property)] ? "Array" !== propertyType || visited[objId(property)] || (visited[objId(property)] = !0, 
                    DFS(property, callback, i, visited)) : (visited[objId(property)] = !0, DFS(property, callback, null, visited));
                }
            }
        },
        plugins: {},
        highlightAll: function(async, callback) {
            _.highlightAllUnder(document, async, callback);
        },
        highlightAllUnder: function(container, async, callback) {
            var env = {
                callback: callback,
                container: container,
                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _.hooks.run("before-highlightall", env), env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector)), 
            _.hooks.run("before-all-elements-highlight", env);
            for (var element, i = 0; element = env.elements[i++]; ) _.highlightElement(element, !0 === async, env.callback);
        },
        highlightElement: function(element, async, callback) {
            var language = _.util.getLanguage(element), grammar = _.languages[language];
            element.className = element.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
            var parent = element.parentNode;
            parent && "pre" === parent.nodeName.toLowerCase() && (parent.className = parent.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language);
            var env = {
                element: element,
                language: language,
                grammar: grammar,
                code: element.textContent
            };
            function insertHighlightedCode(highlightedCode) {
                env.highlightedCode = highlightedCode, _.hooks.run("before-insert", env), env.element.innerHTML = env.highlightedCode, 
                _.hooks.run("after-highlight", env), _.hooks.run("complete", env), callback && callback.call(env.element);
            }
            if (_.hooks.run("before-sanity-check", env), !env.code) return _.hooks.run("complete", env), 
            void (callback && callback.call(env.element));
            if (_.hooks.run("before-highlight", env), env.grammar) if (async && _self.Worker) {
                var worker = new Worker(_.filename);
                worker.onmessage = function(evt) {
                    insertHighlightedCode(evt.data);
                }, worker.postMessage(JSON.stringify({
                    language: env.language,
                    code: env.code,
                    immediateClose: !0
                }));
            } else insertHighlightedCode(_.highlight(env.code, env.grammar, env.language)); else insertHighlightedCode(_.util.encode(env.code));
        },
        highlight: function(text, grammar, language) {
            var env = {
                code: text,
                grammar: grammar,
                language: language
            };
            return _.hooks.run("before-tokenize", env), env.tokens = _.tokenize(env.code, env.grammar), 
            _.hooks.run("after-tokenize", env), Token.stringify(_.util.encode(env.tokens), env.language);
        },
        tokenize: function(text, grammar) {
            var rest = grammar.rest;
            if (rest) {
                for (var token in rest) grammar[token] = rest[token];
                delete grammar.rest;
            }
            var tokenList = new LinkedList();
            return addAfter(tokenList, tokenList.head, text), function matchGrammar(text, tokenList, grammar, startNode, startPos, oneshot, target) {
                for (var token in grammar) if (grammar.hasOwnProperty(token) && grammar[token]) {
                    var patterns = grammar[token];
                    patterns = Array.isArray(patterns) ? patterns : [ patterns ];
                    for (var j = 0; j < patterns.length; ++j) {
                        if (target && target == token + "," + j) return;
                        var pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;
                        if (greedy && !pattern.pattern.global) {
                            var flags = pattern.pattern.toString().match(/[imsuy]*$/)[0];
                            pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
                        }
                        pattern = pattern.pattern || pattern;
                        for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, 
                        currentNode = currentNode.next) {
                            var str = currentNode.value;
                            if (tokenList.length > text.length) return;
                            if (!(str instanceof Token)) {
                                var removeCount = 1;
                                if (greedy && currentNode != tokenList.tail.prev) {
                                    pattern.lastIndex = pos;
                                    var match = pattern.exec(text);
                                    if (!match) break;
                                    var from = match.index + (lookbehind && match[1] ? match[1].length : 0), to = match.index + match[0].length, p = pos;
                                    for (p += currentNode.value.length; p <= from; ) currentNode = currentNode.next, 
                                    p += currentNode.value.length;
                                    if (p -= currentNode.value.length, pos = p, currentNode.value instanceof Token) continue;
                                    for (var k = currentNode; k !== tokenList.tail && (p < to || "string" == typeof k.value && !k.prev.value.greedy); k = k.next) removeCount++, 
                                    p += k.value.length;
                                    removeCount--, str = text.slice(pos, p), match.index -= pos;
                                } else {
                                    pattern.lastIndex = 0;
                                    var match = pattern.exec(str);
                                }
                                if (match) {
                                    lookbehind && (lookbehindLength = match[1] ? match[1].length : 0);
                                    var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to), removeFrom = currentNode.prev;
                                    before && (removeFrom = addAfter(tokenList, removeFrom, before), pos += before.length), 
                                    removeRange(tokenList, removeFrom, removeCount);
                                    var wrapped = new Token(token, inside ? _.tokenize(match, inside) : match, alias, match, greedy);
                                    if (currentNode = addAfter(tokenList, removeFrom, wrapped), after && addAfter(tokenList, currentNode, after), 
                                    1 < removeCount && matchGrammar(text, tokenList, grammar, currentNode.prev, pos, !0, token + "," + j), 
                                    oneshot) break;
                                } else if (oneshot) break;
                            }
                        }
                    }
                }
            }(text, tokenList, grammar, tokenList.head, 0), function(list) {
                var array = [], node = list.head.next;
                for (;node !== list.tail; ) array.push(node.value), node = node.next;
                return array;
            }(tokenList);
        },
        hooks: {
            all: {},
            add: function(name, callback) {
                var hooks = _.hooks.all;
                hooks[name] = hooks[name] || [], hooks[name].push(callback);
            },
            run: function(name, env) {
                var callbacks = _.hooks.all[name];
                if (callbacks && callbacks.length) for (var callback, i = 0; callback = callbacks[i++]; ) callback(env);
            }
        },
        Token: Token
    };
    function Token(type, content, alias, matchedStr, greedy) {
        this.type = type, this.content = content, this.alias = alias, this.length = 0 | (matchedStr || "").length, 
        this.greedy = !!greedy;
    }
    function LinkedList() {
        var head = {
            value: null,
            prev: null,
            next: null
        }, tail = {
            value: null,
            prev: head,
            next: null
        };
        head.next = tail, this.head = head, this.tail = tail, this.length = 0;
    }
    function addAfter(list, node, value) {
        var next = node.next, newNode = {
            value: value,
            prev: node,
            next: next
        };
        return node.next = newNode, next.prev = newNode, list.length++, newNode;
    }
    function removeRange(list, node, count) {
        for (var next = node.next, i = 0; i < count && next !== list.tail; i++) next = next.next;
        (node.next = next).prev = node, list.length -= i;
    }
    if (_self.Prism = _, Token.stringify = function stringify(o, language) {
        if ("string" == typeof o) return o;
        if (Array.isArray(o)) {
            var s = "";
            return o.forEach(function(e) {
                s += stringify(e, language);
            }), s;
        }
        var env = {
            type: o.type,
            content: stringify(o.content, language),
            tag: "span",
            classes: [ "token", o.type ],
            attributes: {},
            language: language
        }, aliases = o.alias;
        aliases && (Array.isArray(aliases) ? Array.prototype.push.apply(env.classes, aliases) : env.classes.push(aliases)), 
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    }, !_self.document) return _self.addEventListener && (_.disableWorkerMessageHandler || _self.addEventListener("message", function(evt) {
        var message = JSON.parse(evt.data), lang = message.language, code = message.code, immediateClose = message.immediateClose;
        _self.postMessage(_.highlight(code, _.languages[lang], lang)), immediateClose && _self.close();
    }, !1)), _;
    var script = _.util.currentScript();
    function highlightAutomaticallyCallback() {
        _.manual || _.highlightAll();
    }
    if (script && (_.filename = script.src, script.hasAttribute("data-manual") && (_.manual = !0)), 
    !_.manual) {
        var readyState = document.readyState;
        "loading" === readyState || "interactive" === readyState && script && script.defer ? document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback) : window.requestAnimationFrame ? window.requestAnimationFrame(highlightAutomaticallyCallback) : window.setTimeout(highlightAutomaticallyCallback, 16);
    }
    return _;
}(_self);

"undefined" != typeof module && module.exports && (module.exports = Prism), "undefined" != typeof global && (global.Prism = Prism), 
Prism.languages.markup = {
    comment: /<!--[\s\S]*?-->/,
    prolog: /<\?[\s\S]+?\?>/,
    doctype: {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:(?!<!--)[^"'\]]|"[^"]*"|'[^']*'|<!--[\s\S]*?-->)*\]\s*)?>/i,
        greedy: !0
    },
    cdata: /<!\[CDATA\[[\s\S]*?]]>/i,
    tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/i,
        greedy: !0,
        inside: {
            tag: {
                pattern: /^<\/?[^\s>\/]+/i,
                inside: {
                    punctuation: /^<\/?/,
                    namespace: /^[^\s>\/:]+:/
                }
            },
            "attr-value": {
                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,
                inside: {
                    punctuation: [ /^=/, {
                        pattern: /^(\s*)["']|["']$/,
                        lookbehind: !0
                    } ]
                }
            },
            punctuation: /\/?>/,
            "attr-name": {
                pattern: /[^\s>\/]+/,
                inside: {
                    namespace: /^[^\s>\/:]+:/
                }
            }
        }
    },
    entity: /&#?[\da-z]{1,8};/i
}, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, 
Prism.hooks.add("wrap", function(env) {
    "entity" === env.type && (env.attributes.title = env.content.replace(/&amp;/, "&"));
}), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    value: function(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: !0,
            inside: Prism.languages[lang]
        }, includedCdataInside.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
            "included-cdata": {
                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                inside: includedCdataInside
            }
        };
        inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
            pattern: RegExp(/(<__[\s\S]*?>)(?:<!\[CDATA\[[\s\S]*?\]\]>\s*|[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
                return tagName;
            }), "i"),
            lookbehind: !0,
            greedy: !0,
            inside: inside
        }, Prism.languages.insertBefore("markup", "cdata", def);
    }
}), Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.html = Prism.languages.markup, 
Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, 
function(Prism) {
    var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
    Prism.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
            pattern: /@[\w-]+[\s\S]*?(?:;|(?=\s*\{))/,
            inside: {
                rule: /^@[\w-]+/,
                "selector-function-argument": {
                    pattern: /(\bselector\s*\((?!\s*\))\s*)(?:[^()]|\((?:[^()]|\([^()]*\))*\))+?(?=\s*\))/,
                    lookbehind: !0,
                    alias: "selector"
                }
            }
        },
        url: {
            pattern: RegExp("url\\((?:" + string.source + "|[^\n\r()]*)\\)", "i"),
            greedy: !0,
            inside: {
                function: /^url/i,
                punctuation: /^\(|\)$/
            }
        },
        selector: RegExp("[^{}\\s](?:[^{};\"']|" + string.source + ")*?(?=\\s*\\{)"),
        string: {
            pattern: string,
            greedy: !0
        },
        property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
        important: /!important\b/i,
        function: /[-a-z0-9]+(?=\()/i,
        punctuation: /[(){};:,]/
    }, Prism.languages.css.atrule.inside.rest = Prism.languages.css;
    var markup = Prism.languages.markup;
    markup && (markup.tag.addInlined("style", "css"), Prism.languages.insertBefore("inside", "attr-value", {
        "style-attr": {
            pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
            inside: {
                "attr-name": {
                    pattern: /^\s*style/i,
                    inside: markup.tag.inside
                },
                punctuation: /^\s*=\s*['"]|['"]\s*$/,
                "attr-value": {
                    pattern: /.+/i,
                    inside: Prism.languages.css
                }
            },
            alias: "language-css"
        }
    }, markup.tag));
}(Prism), Prism.languages.clike = {
    comment: [ {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
    } ],
    string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
    },
    "class-name": {
        pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
            punctuation: /[.\\]/
        }
    },
    keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    boolean: /\b(?:true|false)\b/,
    function: /\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
}, Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [ Prism.languages.clike["class-name"], {
        pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
        lookbehind: !0
    } ],
    keyword: [ {
        pattern: /((?:^|})\s*)(?:catch|finally)\b/,
        lookbehind: !0
    }, {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
    } ],
    number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
    function: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    operator: /--|\+\+|\*\*=?|=>|&&|\|\||[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?[.?]?|[~:]/
}), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/, 
Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
        pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*[\s\S]*?\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
        lookbehind: !0,
        greedy: !0
    },
    "function-variable": {
        pattern: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
        alias: "function"
    },
    parameter: [ {
        pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
        lookbehind: !0,
        inside: Prism.languages.javascript
    }, {
        pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
        inside: Prism.languages.javascript
    }, {
        pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
    }, {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
    } ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
}), Prism.languages.insertBefore("javascript", "string", {
    "template-string": {
        pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
        greedy: !0,
        inside: {
            "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
            },
            interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
                lookbehind: !0,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\${|}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.javascript
                }
            },
            string: /[\s\S]+/
        }
    }
}), Prism.languages.markup && Prism.languages.markup.tag.addInlined("script", "javascript"), 
Prism.languages.js = Prism.languages.javascript, "undefined" != typeof self && self.Prism && self.document && document.querySelector && (self.Prism.fileHighlight = function(container) {
    container = container || document;
    var Extensions = {
        js: "javascript",
        py: "python",
        rb: "ruby",
        ps1: "powershell",
        psm1: "powershell",
        sh: "bash",
        bat: "batch",
        h: "c",
        tex: "latex"
    };
    Array.prototype.slice.call(container.querySelectorAll("pre[data-src]")).forEach(function(pre) {
        if (!pre.hasAttribute("data-src-loaded")) {
            for (var language, src = pre.getAttribute("data-src"), parent = pre, lang = /\blang(?:uage)?-([\w-]+)\b/i; parent && !lang.test(parent.className); ) parent = parent.parentNode;
            if (parent && (language = (pre.className.match(lang) || [ , "" ])[1]), !language) {
                var extension = (src.match(/\.(\w+)$/) || [ , "" ])[1];
                language = Extensions[extension] || extension;
            }
            var code = document.createElement("code");
            code.className = "language-" + language, pre.textContent = "", code.textContent = "Loading…", 
            pre.appendChild(code);
            var xhr = new XMLHttpRequest();
            xhr.open("GET", src, !0), xhr.onreadystatechange = function() {
                4 == xhr.readyState && (xhr.status < 400 && xhr.responseText ? (code.textContent = xhr.responseText, 
                Prism.highlightElement(code), pre.setAttribute("data-src-loaded", "")) : 400 <= xhr.status ? code.textContent = "✖ Error " + xhr.status + " while fetching file: " + xhr.statusText : code.textContent = "✖ Error: File does not exist or is empty");
            }, xhr.send(null);
        }
    });
}, document.addEventListener("DOMContentLoaded", function() {
    self.Prism.fileHighlight();
})), function() {
    var assign = Object.assign || function(obj1, obj2) {
        for (var name in obj2) obj2.hasOwnProperty(name) && (obj1[name] = obj2[name]);
        return obj1;
    };
    function NormalizeWhitespace(defaults) {
        this.defaults = assign({}, defaults);
    }
    function tabLen(str) {
        for (var res = 0, i = 0; i < str.length; ++i) str.charCodeAt(i) == "\t".charCodeAt(0) && (res += 3);
        return str.length + res;
    }
    NormalizeWhitespace.prototype = {
        setDefaults: function(defaults) {
            this.defaults = assign(this.defaults, defaults);
        },
        normalize: function(input, settings) {
            for (var name in settings = assign(this.defaults, settings)) {
                var methodName = name.replace(/-(\w)/g, function(match, firstChar) {
                    return firstChar.toUpperCase();
                });
                "normalize" !== name && "setDefaults" !== methodName && settings[name] && this[methodName] && (input = this[methodName].call(this, input, settings[name]));
            }
            return input;
        },
        leftTrim: function(input) {
            return input.replace(/^\s+/, "");
        },
        rightTrim: function(input) {
            return input.replace(/\s+$/, "");
        },
        tabsToSpaces: function(input, spaces) {
            return spaces = 0 | spaces || 4, input.replace(/\t/g, new Array(++spaces).join(" "));
        },
        spacesToTabs: function(input, spaces) {
            return spaces = 0 | spaces || 4, input.replace(RegExp(" {" + spaces + "}", "g"), "\t");
        },
        removeTrailing: function(input) {
            return input.replace(/\s*?$/gm, "");
        },
        removeInitialLineFeed: function(input) {
            return input.replace(/^(?:\r?\n|\r)/, "");
        },
        removeIndent: function(input) {
            var indents = input.match(/^[^\S\n\r]*(?=\S)/gm);
            return indents && indents[0].length ? (indents.sort(function(a, b) {
                return a.length - b.length;
            }), indents[0].length ? input.replace(RegExp("^" + indents[0], "gm"), "") : input) : input;
        },
        indent: function(input, tabs) {
            return input.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++tabs).join("\t") + "$&");
        },
        breakLines: function(input, characters) {
            characters = !0 === characters ? 80 : 0 | characters || 80;
            for (var lines = input.split("\n"), i = 0; i < lines.length; ++i) if (!(tabLen(lines[i]) <= characters)) {
                for (var line = lines[i].split(/(\s+)/g), len = 0, j = 0; j < line.length; ++j) {
                    var tl = tabLen(line[j]);
                    characters < (len += tl) && (line[j] = "\n" + line[j], len = tl);
                }
                lines[i] = line.join("");
            }
            return lines.join("\n");
        }
    }, "undefined" != typeof module && module.exports && (module.exports = NormalizeWhitespace), 
    void 0 !== Prism && (Prism.plugins.NormalizeWhitespace = new NormalizeWhitespace({
        "remove-trailing": !0,
        "remove-indent": !0,
        "left-trim": !0,
        "right-trim": !0
    }), Prism.hooks.add("before-sanity-check", function(env) {
        var Normalizer = Prism.plugins.NormalizeWhitespace;
        if (!env.settings || !1 !== env.settings["whitespace-normalization"]) if (env.element && env.element.parentNode || !env.code) {
            var pre = env.element.parentNode, clsReg = /(?:^|\s)no-whitespace-normalization(?:\s|$)/;
            if (env.code && pre && "pre" === pre.nodeName.toLowerCase() && !clsReg.test(pre.className) && !clsReg.test(env.element.className)) {
                for (var children = pre.childNodes, before = "", after = "", codeFound = !1, i = 0; i < children.length; ++i) {
                    var node = children[i];
                    node == env.element ? codeFound = !0 : "#text" === node.nodeName && (codeFound ? after += node.nodeValue : before += node.nodeValue, 
                    pre.removeChild(node), --i);
                }
                if (env.element.children.length && Prism.plugins.KeepMarkup) {
                    var html = before + env.element.innerHTML + after;
                    env.element.innerHTML = Normalizer.normalize(html, env.settings), env.code = env.element.textContent;
                } else env.code = before + env.code + after, env.code = Normalizer.normalize(env.code, env.settings);
            }
        } else env.code = Normalizer.normalize(env.code, env.settings);
    }));
}(), function() {
    if ("undefined" != typeof self && self.Prism && self.document) {
        Prism.hooks.add("complete", function(env) {
            if (env.code) {
                var pre = env.element.parentNode, clsReg = /\s*\bline-numbers\b\s*/;
                if (pre && /pre/i.test(pre.nodeName) && (clsReg.test(pre.className) || clsReg.test(env.element.className)) && !env.element.querySelector(".line-numbers-rows")) {
                    0, clsReg.test(env.element.className) && (env.element.className = env.element.className.replace(clsReg, "")), 
                    clsReg.test(pre.className) || (pre.className += " line-numbers");
                    var lineNumbersWrapper, match = env.code.match(/\n(?!$)/g), linesNum = match ? match.length + 1 : 1, start = 1;
                    pre.hasAttribute("data-start") && (start = parseInt(pre.getAttribute("data-start"), 10));
                    for (var name, len = linesNum + 1, lines = "", i = start; i < len; i++) lines += '<a href="#' + (name = "line-" + i) + '" name="' + name + '"></a>';
                    (lineNumbersWrapper = document.createElement("span")).className = "line-numbers-rows", 
                    lineNumbersWrapper.innerHTML = lines, pre.hasAttribute("data-start") && (pre.style.counterReset = "linenumber " + (start - 1)), 
                    env.element.appendChild(lineNumbersWrapper);
                }
            }
        });
    }
}(), function() {
    if ("undefined" != typeof self && self.Prism && self.document) {
        var callbacks = [], map = {}, noop = function() {};
        Prism.plugins.toolbar = {};
        var registerButton = Prism.plugins.toolbar.registerButton = function(key, opts) {
            var callback;
            callback = "function" == typeof opts ? opts : function(env) {
                var element;
                return "function" == typeof opts.onClick ? ((element = document.createElement("button")).type = "button", 
                element.addEventListener("click", function() {
                    opts.onClick.call(this, env);
                })) : "string" == typeof opts.url ? (element = document.createElement("a")).href = opts.url : element = document.createElement("span"), 
                element.textContent = opts.text, element;
            }, callbacks.push(map[key] = callback);
        }, hook = Prism.plugins.toolbar.hook = function(env) {
            var pre = env.element.parentNode;
            if (pre && /pre/i.test(pre.nodeName) && !pre.classList.contains("code-toolbar")) {
                pre.classList.add("code-toolbar");
                var toolbar = document.createElement("div");
                toolbar.classList.add("toolbar"), document.body.hasAttribute("data-toolbar-order") && (callbacks = document.body.getAttribute("data-toolbar-order").split(",").map(function(key) {
                    return map[key] || noop;
                })), callbacks.forEach(function(callback) {
                    var element = callback(env);
                    if (element) {
                        var item = document.createElement("div");
                        item.classList.add("toolbar-item"), item.appendChild(element), toolbar.appendChild(item);
                    }
                });
                var wrapper = document.createElement("div");
                wrapper.className = pre.className, wrapper.classList.add("toolbar-wrapper"), pre.className = "", 
                pre.parentNode.insertBefore(wrapper, pre), wrapper.appendChild(toolbar), wrapper.appendChild(pre);
            }
        };
        registerButton("label", function(env) {
            var pre = env.element.parentNode;
            if (pre && /pre/i.test(pre.nodeName) && pre.hasAttribute("data-label")) {
                var element, template, text = pre.getAttribute("data-label");
                try {
                    template = document.querySelector("template#" + text);
                } catch (e) {}
                return template ? element = template.content : (pre.hasAttribute("data-url") ? (element = document.createElement("a")).href = pre.getAttribute("data-url") : element = document.createElement("span"), 
                element.innerHTML = text), element;
            }
        }), Prism.hooks.add("complete", hook);
    }
}(), function() {
    if ("undefined" != typeof self && self.Prism && self.document) if (Prism.plugins.toolbar) {
        var Clipboard = window.ClipboardJS || void 0;
        Clipboard || "function" != typeof require || (Clipboard = require("clipboard"));
        var callbacks = [];
        if (!Clipboard) {
            var script = document.createElement("script"), head = document.querySelector("head");
            script.onload = function() {
                if (Clipboard = window.ClipboardJS) for (;callbacks.length; ) callbacks.pop()();
            }, script.src = "https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.1/clipboard.min.js", 
            head.appendChild(script);
        }
        Prism.plugins.toolbar.registerButton("copy-to-clipboard", function(env) {
            var linkCopy = document.createElement("a");
            function resetText() {
                setTimeout(function() {
                    linkCopy.textContent = "Copy";
                }, 5e3);
            }
            function registerClipboard() {
                var clip = new Clipboard(linkCopy, {
                    text: function() {
                        return env.code;
                    }
                });
                clip.on("success", function() {
                    linkCopy.textContent = "Copied!", resetText();
                }), clip.on("error", function() {
                    linkCopy.textContent = "Press Ctrl+C to copy", resetText();
                });
            }
            return linkCopy.textContent = "Copy", linkCopy.className = "prism-copy-to-clipboard", 
            Clipboard ? registerClipboard() : callbacks.push(registerClipboard), linkCopy;
        });
    } else console.warn("Copy to Clipboard plugin loaded before Toolbar plugin.");
}();